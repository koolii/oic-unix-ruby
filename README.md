# なるほどUnixプロセス(Ruby)

## ２章
* カーネルとのやりとりは全てシステムコール経由でなければならない
* システムコールのインターフェースがカーネルとユーザーランドとを取り次ぐ
* ユーザーランドは、あなたの書いたプログラムが実行される場所
* あらゆるコードはプロセス上で実行される

## ３章
* プロセスの現在のpidはグローバル変数$$にも保持されているし、Process.pid(getpid(2)に対応)でも取得できる

## ４章
* プロセスの親のpidはProcess.ppid(getppid(2)に対応している)で取得できる

## ５章
* Rubyでは、開いたリソースはIOクラスで表現している、IOオブジェクトは自身のファイルディスクリプタを知っていて、IO#filenoで取得できる

```ruby
# 開いている最小の番号がディスクリプタに割り当てられる(0-2は標準入出力エラー)
passwd = File.open('/etc/passwd')
puts passwd.fileno # => 3

hosts = File.open('/etc/hosts')
puts hosts.fileno # => 4

# ファイルをクローズ(ファイルディスクリプタを閉じることになるため、番号は開放される)
passwd.close

null = File.open('/dev/null')
puts null.fileno # => 3
```

## ６章
一つのプロセスでファイルディスクリプタはいくつ開けるのだろうか。
まず、ファイルディスクリプタはソフトリミットとハードリミットが存在し、ソフトリミットを超えると例外が発生する
ハードリミットは無限大くらい大きい値になっていて、ハードリミットに達する前にハードの方が壊れてしまう方が早い

また、これらの値はRubyのコードから任意の値に変更することが可能
下記の様なコードは一つのプロセスが同時に数千のネットワークコネクションを扱う必要がある場合などに有効利用ができる

```ruby
# オープンできるファイルの最大数を3に設定
# 標準ストリームでファイルディスクリプタを3つ使うため、すでに上限に達している
Process.setrlimit(:NOFILE, 3)
File.open('/dev/null')o

# => Errno::EMFILE: Too many open files - /dev/null
#	from (irb):2:in `initialize'
#	from (irb):2:in `open'
#	from (irb):2
#	from /usr/bin/irb:12:in `<main>'

# プロセスのユーザが作成できる最大プロセス数
Process.getrlimit(:NPRO)
# プロセスが作成できるファイルサイズの最大値
Process.getrlimit(:FSIZE)
# プロセススタックの最大サイズ
Process.getrlimit(:STACK)
```

## ７章
環境変数はハッシュのようになっているが、メソッドなどが備わっておらず、ハッシュとは言いにくい
これらはRubyのENVと言うグローバル変数などのコマンドラインツールの入力に渡す方法としてよく使われる

## ８章
RubyプロセスはARGVという特別な配列(Array)を持っている
よく使われるのは例に漏れず、プログラムにファイル名を渡したい場合
Rubyにはコマンドライン引数の解析ライブラリがいくつもあるが、簡単なフラグ程度なら、配列を直接操作して実装してみるのも良さげ

## ９章
irbコマンドを入力すると、プロセスの名前は「irb」となるが、Rubyの環境変数を変更することでプロセス名を変更することが可能
プロセス名の有効活用例は「Resqueのプロセス管理」とのこと。（まだそこまで読み進めていない）

```ruby
puts $PROGRAM_NAME

10..downto(1) do |num|
  $PROGRAM_NAME = "Process: #{num}"
  puts $PROGRAM_NAME
end
```

## １０章
プロセスの終了で一番簡単なのはKernel#exitを使って正常終了させること（任意の終了コードで終わらせることもできる）
Kernel#at_exitで定義された全てのブロックが呼び出される
Kernel#exit!(!= Kernel#exit)は終了コードのデフォルトが異常終了(1)で、Kernel#at_exitで定義されたブロックは実行されない
Kernel#abortは問題のあったプロセスを終了させる場合によく使われる
Kernel#raiseは例外として扱われるのですぐにはプロセスが終了しない