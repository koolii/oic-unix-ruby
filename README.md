# なるほどUnixプロセス(Ruby)

## ２章
* カーネルとのやりとりは全てシステムコール経由でなければならない
* システムコールのインターフェースがカーネルとユーザーランドとを取り次ぐ
* ユーザーランドは、あなたの書いたプログラムが実行される場所
* あらゆるコードはプロセス上で実行される

## ３章
* プロセスの現在のpidはグローバル変数$$にも保持されているし、Process.pid(getpid(2)に対応)でも取得できる

## ４章
* プロセスの親のpidはProcess.ppid(getppid(2)に対応している)で取得できる

## ５章
* Rubyでは、開いたリソースはIOクラスで表現している、IOオブジェクトは自身のファイルディスクリプタを知っていて、IO#filenoで取得できる

```ruby
# 開いている最小の番号がディスクリプタに割り当てられる(0-2は標準入出力エラー)
passwd = File.open('/etc/passwd')
puts passwd.fileno # => 3

hosts = File.open('/etc/hosts')
puts hosts.fileno # => 4

# ファイルをクローズ(ファイルディスクリプタを閉じることになるため、番号は開放される)
passwd.close

null = File.open('/dev/null')
puts null.fileno # => 3
```

## ６章
一つのプロセスでファイルディスクリプタはいくつ開けるのだろうか。
まず、ファイルディスクリプタはソフトリミットとハードリミットが存在し、ソフトリミットを超えると例外が発生する
ハードリミットは無限大くらい大きい値になっていて、ハードリミットに達する前にハードの方が壊れてしまう方が早い

また、これらの値はRubyのコードから任意の値に変更することが可能
下記の様なコードは一つのプロセスが同時に数千のネットワークコネクションを扱う必要がある場合などに有効利用ができる

```ruby
# オープンできるファイルの最大数を3に設定
# 標準ストリームでファイルディスクリプタを3つ使うため、すでに上限に達している
Process.setrlimit(:NOFILE, 3)
File.open('/dev/null')o

# => Errno::EMFILE: Too many open files - /dev/null
#	from (irb):2:in `initialize'
#	from (irb):2:in `open'
#	from (irb):2
#	from /usr/bin/irb:12:in `<main>'

# プロセスのユーザが作成できる最大プロセス数
Process.getrlimit(:NPRO)
# プロセスが作成できるファイルサイズの最大値
Process.getrlimit(:FSIZE)
# プロセススタックの最大サイズ
Process.getrlimit(:STACK)
```

## ７章
環境変数はハッシュのようになっているが、メソッドなどが備わっておらず、ハッシュとは言いにくい
これらはRubyのENVと言うグローバル変数などのコマンドラインツールの入力に渡す方法としてよく使われる

## ８章
RubyプロセスはARGVという特別な配列(Array)を持っている
よく使われるのは例に漏れず、プログラムにファイル名を渡したい場合
Rubyにはコマンドライン引数の解析ライブラリがいくつもあるが、簡単なフラグ程度なら、配列を直接操作して実装してみるのも良さげ

## ９章
irbコマンドを入力すると、プロセスの名前は「irb」となるが、Rubyの環境変数を変更することでプロセス名を変更することが可能
プロセス名の有効活用例は「Resqueのプロセス管理」とのこと。（まだそこまで読み進めていない）

```ruby
puts $PROGRAM_NAME

10..downto(1) do |num|
  $PROGRAM_NAME = "Process: #{num}"
  puts $PROGRAM_NAME
end
```

## １０章
プロセスの終了で一番簡単なのはKernel#exitを使って正常終了させること（任意の終了コードで終わらせることもできる）
Kernel#at_exitで定義された全てのブロックが呼び出される
Kernel#exit!(!= Kernel#exit)は終了コードのデフォルトが異常終了(1)で、Kernel#at_exitで定義されたブロックは実行されない
Kernel#abortは問題のあったプロセスを終了させる場合によく使われる
Kernel#raiseは例外として扱われるのですぐにはプロセスが終了しない

## １１章
fork(2)して子プロセスを生成することはUnixプログラミングで最も強力な考え方の１つ
実行中のプロセスから新しいプロセスを生成できる、新プロセスは元プロセスの完全なコピー
子プロセスは親プロセスで使われている全てのメモリのコピーを引き継ぐ、親プロセスが開いているファイルディスクリプタも同様に引き継ぐ
なので、２つのプロセスで開いているファイルやソケットなどを共有出来るということ
Railsの様にメモリ上に巨大なソフトウェアのコピーを効率的に持つことが出来るのでアプリケーションのインスタンスを複数同時に立ち上げるのが便利
なぜなら、アプリケーションを読み込む必要があるプロセスは一つだけで、forkも早いから、同じアプリケーションを別々に読み込むより早い

ブロック付きでforkメソッドを呼出した場合、ブロックは子プロセスのみで実行されて、親プロセスでは無視される、子プロセスはブロック内の処理が終わったらそこで終了し、親プロセス皮の処理は続行しない
実用的な活用法は付録やSpyglassを参照する

```ruby
fork do
  # 子プロセスで実行する処理を個々に記述する
end

# 親プロセスで実行する処理を個々に記述する
```

## １２章
端末からプロセスを作成し、複数のプロセスが存在した上でCtrl+Cでプロセスを終了させた時に、親プロセスは死ぬが、子プロセスによってSTDOUTが上書きされてしまう(奇妙)
よって、子プロセスには「何もおきない」、OS側は親プロセスが死ぬ時に子プロセスを道連れにしない

```ruby
fork do
  5.times do
    sleep 1
    puts "I'm an orphan!"
  end
end

abort "Parent process died..."
```